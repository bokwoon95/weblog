- TODO: Still need to figure out:
    - How to organize templates? User preps TemplateSource, TemplateSources? Then transfer data over to the more private Template/Templates structs?
    - Common templates are already baked into the *template.Template, right? How about common Assets? And common preprocessors? How should they be reachable?
        - While the Template either holds info needed to either parse from scratch or a pre-cached *template.Template, I think the common assets/preprocessors should reside in the *Templates struct.
        - In fact I think a Template by itself should not be exposed to the user at all. It simply doesn't make sense without the greater context of the common assets and common preprocessors. And I'm not making those public in case the user modifies them mid-request and causes a race condition.
    - How to settle template names? I know their names by default should be their file path in the FS. But then what about template that are overriding some kind of base template? If you invoke these templates by their name, the *template.Template should execute the base template instead. How should users indicate that? Where in the struct do I store this info?
- Adding the CSP script-src-elem and style-src-elem policies should be inside a preprocessor function. This is because the assets are only known when the template is known i.e. after the call to Render(). And instead of making the hash an Asset field, I should make a cache mapping the File.FullName() to the hash so I don't have to compute the hash for every damn asset, instead I just look it up in the map. If not exist I'll hash it on the spot and store it back in the map (this will require a RWMutex).

- Move the computation of CSS/JS payloads for each solo template to Parse() time (i.e. cached, just like with templates).
    - https://stackoverflow.com/questions/40584612/how-to-get-a-map-or-list-of-template-actions-from-a-parsed-template
- Also compute the hash of each CSS/JS payload at Parse() time.
    {{ range $i, $css := .__wt_css__ }}
    {{ range $i, $js := .__wt_js__ }}
- Implement the AddFiles function to include options, maybe at the start? What a radical idea. I have two variadic streams of arguments, filenames and options. How to reconcile the two?
    - option1: do you want an absolute prefix?
    - option2: do you want to include CSS files of the same name?
    - option3: do you want to include JS files of the same name?
    - option4: do you want CSS/JS resources to be inlined, or served separately?
        - how to override this on a per-template level?
- How to make persist changes to contenteditable elements to the database, and how to then retrieve it?
    - every contenteditable element has an id which is the key. The innerHTML is the value. A javascript function gathers up items tagged with '.conteneditable' into a JSON payload and does a POST request to /pm-kv. On success it simply reloads the current page.
- What does the API for user-editable fields look like to the template creator?
    <h1 id="plugin_name:title" class="{{ template "pagemanager:contenteditable" . }}">
        {{ $res := pm_kv "plugin_name:title" }}
        {{ if $res.Valid }}{{ $res.Value }}{{ else }}default text{{ end }}
    </h1>
    - pm_kv "plugin_name:title" will pull the relevant value from the database/cache.
    - id="plugin_name:title" together with class="pm-contenteditable" will trigger a pagemanager javascript snippet to transform it into a contenteditable element, and then pulls the value from that element and saves it to the database/cache.
    - quite neat! This isn't even blog stuff, it's inherent in pagemanager. You can use this system for any kind of template that targets pagemanager.

- wt comes with a few map-related helper template functions (that can be optionally disabled by the user)
    - wt_dict: constructs a new map
    - wt_dict_add: makes a copy of the first map argument, then adds the subsequent key values to it
    - wt_dict_cherrypick/filter: makes a copy of the first map argument by only picking the key arguments passed to it
    - or should I do wt_map_graft instead? wt_map_graft $ (wt_map key1 value1 key2 value2 ...)

long term goals:
- pagemanager should be able to read html/markdown files from the current folder (user-configurable) and translate it into static HTML pages in the pm_routes table. This allows users to manually edit markdown files with their favorite text editor, and also allows for large-scale collaboration by making wrapping the files in a git repo (git ignoring the pagemanager binary and sqlite database file of course).
