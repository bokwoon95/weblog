usually pagemanager/blog renders

render.Page(w, r, data, "post-index.html", "post-index.css", "post-index.js")

but before that, it will check the blg_kv table

blg_kv:
    post-index.html -> ~templates/plainsimple/post-index.html
    post.html -> ~templates/plainsimple/post.html

note: pagemanager/blog was the one who registered the templates/ directory under as the 'templates' alt FS. so if it sets ~templates, it's guaranteed that the templatesFS exists because it was the one that registered it

anyway pagemanager/blog will look into the plainsimple/ directory (inside the templates/ directory) and find the config.toml. it feeds "post-index.html" as the key and gets back css = ["style.css"], js = ["post-index.js"], data = { summary = "true", some_other_setting = "lorem ipsum" }.

So instead it calls

render.Page(w, r, data, "~templates/post-index.html", "~templates/style.css", "~templates/post-index.js")

and renderly should search for those files accordingly in templatesFS. Also pagemanager/blog got the data = { summary = "true", some_other_setting = "lorem ipsum" }, it uses that to influence the decisions it makes when it comes to injecting the data into the template, like whether it should provide just the post {{ .Summary }} or the entire post {{ .Body }}.

blg_kv:
    post-index -> ~builtin/post-index.html -> pass 'post-index.html' to
    post-index -> ~templates/plainsimple/post-index.html

pagemanager/pagemanager
pagemanager/sqladmin
pagemanager/blog
pagemanager/rss
pagemanager/present

templates can be standalone or they can target specific pagemanager plugins.
    the only difference between the two is whether it makes reference to a (yet to be injected) data pipeline
Other than pm_kv strings, templates can also pm_kv array of objects (not sure how that will work yet)
    pm_kv-ing an array of objects allows the user to define repeatable cards rather than just fixed ones
a single filename is enough for pagemanager to find all the necessary html/css/js files to parse together with the main template
    templatesFS implements a translation method that reads from config.toml:
        ["post-index.html"]
        html = ["header.html", "footer.html", "sidebar.html"]
        css = ["style.css"]
        js = ["post-index.js"]
    layout templates are achieved with an optional 'main_html' key. If no main_html is provided, the provided filename will be used as the main template (as usual).
        ["about-me.html"]
        main_html = "layout.html"
        html = ["layout.html", "header.html", "footer.html", "sidebar.html"]
        css = ["style.css"]
        js = ["post-index.js"]
            ["about-me.html".args]
            showbody = true
            datefmt = "01/02/03" # or they could just call the datefmt method on the time.Time value
holy shit toml allows me to bundle markdown files as well, you can just define all your layout stuff in html and your content in markdown
    ["my-blogge-post.md"]
    url = "{{.YYYY}}/{{.MM}}/{{.PostTitle}}" # nah this is wayy too tedious, blog posts should belong under pm/blog. this is more for manually curated pages, like mdn docs
    html = ["header.html", "footer.html", "sidebar.html"]
    css = ["style.css"]
    js = []
    md = ["some-other-stuff.md"]
    main_html = "layout.html"

    # reference the content like this
    <div class="post-body">
        {{ index . "__content__" }}
    </div>
    # you can reference other included md snippets like this
    <div class="footer">{{ index . "some-other-stuff.md" }}</div>

    content-specific key values is defined in the content.md front matter
    this means anytime pagemanager finds a content (.md) file, it will parse the front matter and inject that as part of the page data.
    which means that it definitely has to start categorizing .md files as well

each pagemanager/blog post can specify key value pairs as well in the spirit of url.Values. This key value data will be bundled with each post and template authors can explicitly query for it. This allows template authors to show various tags (such as 'short', or 'javascript') based on what key-values the user bundled in their post. This is also a flexible way that can express both tags and categories for a post.

type NullJSON struct {
    Valid bool
    JSON interface{}
    Type int // 0 = Object, 1 = Array, 2 = Value
}

func pmkv(pageID, key, fallbackValue string) sql.NullString

func pmjson(pageID, key, fallbackValye string) NullJSON

{{ $title := pmkv .__pageID__ "title" `default text` }}
<div class="contenteditable" data-kv="title">
    {{ $title.String | html }}
</div>

{{ $sidebarItems := pmjson .__pageID__ "sidebarItems" `[
    {
        "title":"My Name",
        "body":"mario waluigi smith"
    },
    {
        "title":"my job",
        "body":"professional retard"
    }
]`}}
<div>
    <div class="pmjson-ghostnode">
        <div class="contenteditable" data-json="title">default text</div>
        <div class="contenteditable" data-json="body">xxxx</div>
    </div>
    {{ range $sidebarItems.JSON }}
    <div>
        <div class="contenteditable" data-json="title">{{ .title | html }}</div>
        <div class="contenteditable" data-json="body">{{ .body | html }}</div>
    </div>
    {{ end }}
</div>
