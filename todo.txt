- Need some way to Lookup() pages without rendering so that hot pages can be prepped on startup with Lookup(). Does that mean I have to export the Page type? Should I allow the user to access the Page fields and do rendering on their own?
    - I'm super leery about giving write access to the []*assets because users might try to edit it mid request and cause a race condition.
- FileServer implementation, allowing users to either inline their assets or serve it externally. I think there can be an automatic rule that big assets get translated to external assets, while small assets can be inlined. The user can set the size threshold if they want.
    - Other than that there should also be some way to manually indictating if you want to serve an asset externally or not (default is inline).
- Incoming IP (with country), Request Payload Size, Request Start Time, Request End Time, Response Payload Size, Response Status Code, Other Canonical Log Fields (user_id, etc)
- Create a nice, stand-in 500 response handler that the user can use while prototyping, which can be swapped with their own custom handler anytime.

libraries define a name struct that maps all their library names to the actual names. When instantiating templates and shit they have to metatemplate using this struct. Such that the templates themselves are configurable by the user. The template names, the function names, the data names, all configured by modifying values in the struct (or should it be a map? map means the user has to lookup the docs for the names instead of just looking at the struct fields but maybe that's an acceptable compromise).
    - This means I need some kind of translation function that can read in the struct (or map), read in the File (from the native/embedded filesystem) and output another File. I can programatically edit Files.
    - This is done by creating some kind of translation FS that can be created with pure strings produced by reading another FS.

- Move the computation of CSS/JS payloads for each solo template to Parse() time (i.e. cached, just like with templates).
    - https://stackoverflow.com/questions/40584612/how-to-get-a-map-or-list-of-template-actions-from-a-parsed-template
- Also compute the hash of each CSS/JS payload at Parse() time.
    {{ range $i, $css := .__wt_css__ }}
    {{ range $i, $js := .__wt_js__ }}
- Implement the AddFiles function to include options, maybe at the start? What a radical idea. I have two variadic streams of arguments, filenames and options. How to reconcile the two?
    - option1: do you want an absolute prefix?
    - option2: do you want to include CSS files of the same name?
    - option3: do you want to include JS files of the same name?
    - option4: do you want CSS/JS resources to be inlined, or served separately?
        - how to override this on a per-template level?
- How to make persist changes to contenteditable elements to the database, and how to then retrieve it?
    - every contenteditable element has an id which is the key. The innerHTML is the value. A javascript function gathers up items tagged with '.conteneditable' into a JSON payload and does a POST request to /pm-kv. On success it simply reloads the current page.
- What does the API for user-editable fields look like to the template creator?
    <h1 id="plugin_name:title" class="{{ if .__edit_mode__ }}pm-contenteditable{{ end }}">
        {{ $value := pm_kv "plugin_name:title" }}
        {{ if $value.Valid }}{{ $value.HTML }}{{ else }}default text{{ end }}
    </h1>
    - pm_kv "plugin_name:title" will pull the relevant value from the database/cache.
    - id="plugin_name:title" together with class="pm-contenteditable" will trigger a pagemanager javascript snippet to transform it into a contenteditable element, and then pulls the value from that element and saves it to the database/cache.
    - quite neat! This isn't even blog stuff, it's inherent in pagemanager. You can use this system for any kind of template that targets pagemanager.
- How does chi's json/markdown renderer reflect on the middleware/handler names? Did it manage to obtain the handler from a route? I need that.

- wt comes with a few map-related helper template functions (that can be optionally disabled by the user)
    - wt_dict: constructs a new map
    - wt_dict_add: makes a copy of the first map argument, then adds the subsequent key values to it
    - wt_dict_cherrypick/filter: makes a copy of the first map argument by only picking the key arguments passed to it
    - or should I do wt_map_graft instead? wt_map_graft $ (wt_map key1 value1 key2 value2 ...)

long term goals:
- pagemanager should be able to read html/markdown files from the current folder (user-configurable) and translate it into static HTML pages in the pm_routes table. This allows users to manually edit markdown files with their favorite text editor, and also allows for large-scale collaboration by making wrapping the files in a git repo (git ignoring the pagemanager binary and sqlite database file of course).

pagemanager/pagemanager
pagemanager/blog
pagemanager/sq
pagemanager/erro
pagemanager/render
pagemanager/validator
pagemanager/form
pagemanager/handlerutil
