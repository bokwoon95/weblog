- renderutil metrics:
    - Incoming IP (with country), Request Payload Size, Request Start Time, Request End Time, Response Payload Size, Response Status Code, Other Canonical Log Fields (user_id, etc)
- Create a nice, stand-in 500 response handler that the user can use while prototyping, which can be swapped with their own custom handler anytime.

libraries define a name struct that maps all their library names to the actual names. When instantiating templates and shit they have to metatemplate using this struct. Such that the templates themselves are configurable by the user. The template names, the function names, the data names, all configured by modifying values in the struct (or should it be a map? map means the user has to lookup the docs for the names instead of just looking at the struct fields but maybe that's an acceptable compromise).

allow prerender and postrender hooks to be addable and deleteable separately instead of defining everything at the star.

when vendors are adding their own templates/cssdeps/jsdeps, you can check for naming conflicts and raise an error. This will help with the global namespace situation by letting the user know when a naming conflict occurs.

I think vendor css/js urls can be named after the template they are associated with. If there are consecutive css/js assets associated with a template they can be consecutively numbered.
    This will make it easier for the *Render static file server handler to work as well.
    Still haven't figured out how to secure the file server handler to not dump the user's source files if requested. Need some kind of whitelisting/blacklisting.

The way for you to include css/js unconditionally is to add it to the map with the key as an empty string

The template to be executed is the first non-css/non-js file provided, not actually the first file. I am not sure if this is a good thing.

- Move the computation of CSS/JS payloads for each solo template to Parse() time (i.e. cached, just like with templates).
    - https://stackoverflow.com/questions/40584612/how-to-get-a-map-or-list-of-template-actions-from-a-parsed-template
- Also compute the hash of each CSS/JS payload at Parse() time.
    {{ range $i, $css := .__wt_css__ }}
    {{ range $i, $js := .__wt_js__ }}
- Implement the AddFiles function to include options, maybe at the start? What a radical idea. I have two variadic streams of arguments, filenames and options. How to reconcile the two?
    - option1: do you want an absolute prefix?
    - option2: do you want to include CSS files of the same name?
    - option3: do you want to include JS files of the same name?
    - option4: do you want CSS/JS resources to be inlined, or served separately?
        - how to override this on a per-template level?
- How to make persist changes to contenteditable elements to the database, and how to then retrieve it?
    - every contenteditable element has an id which is the key. The innerHTML is the value. A javascript function gathers up items tagged with '.conteneditable' into a JSON payload and does a POST request to /pm-kv. On success it simply reloads the current page.
- What does the API for user-editable fields look like to the template creator?
    <h1 id="plugin_name:title" class="{{ if .__edit_mode__ }}pm-contenteditable{{ end }}">
        {{ $value := pm_kv "plugin_name:title" }}
        {{ if $value.Valid }}{{ $value.HTML }}{{ else }}default text{{ end }}
    </h1>
    - pm_kv "plugin_name:title" will pull the relevant value from the database/cache.
    - id="plugin_name:title" together with class="pm-contenteditable" will trigger a pagemanager javascript snippet to transform it into a contenteditable element, and then pulls the value from that element and saves it to the database/cache.
    - quite neat! This isn't even blog stuff, it's inherent in pagemanager. You can use this system for any kind of template that targets pagemanager.
- How does chi's json/markdown renderer reflect on the middleware/handler names? Did it manage to obtain the handler from a route? I need that.

- wt comes with a few map-related helper template functions (that can be optionally disabled by the user)
    - wt_dict: constructs a new map
    - wt_dict_add: makes a copy of the first map argument, then adds the subsequent key values to it
    - wt_dict_cherrypick/filter: makes a copy of the first map argument by only picking the key arguments passed to it
    - or should I do wt_map_graft instead? wt_map_graft $ (wt_map key1 value1 key2 value2 ...)

I will eventually have to think about serving assets externally instead of inline. But first I must get the inline implementation working.

long term goals:
- pagemanager should be able to read html/markdown files from the current folder (user-configurable) and translate it into static HTML pages in the pm_routes table. This allows users to manually edit markdown files with their favorite text editor, and also allows for large-scale collaboration by making wrapping the files in a git repo (git ignoring the pagemanager binary and sqlite database file of course).

pagemanager/pagemanager
pagemanager/blog
pagemanager/sq
pagemanager/erro
pagemanager/render
pagemanager/validator
pagemanager/form
pagemanager/handlerutil
