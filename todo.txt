- Move the computation of CSS/JS payloads for each solo template to Parse() time (i.e. cached, just like with templates).
    - https://stackoverflow.com/questions/40584612/how-to-get-a-map-or-list-of-template-actions-from-a-parsed-template
- Also compute the hash of each CSS/JS payload at Parse() time.
    {{ range $i, $css := .__wt_css__ }}
    {{ range $i, $js := .__wt_js__ }}
- Implement the AddFiles function to include options, maybe at the start? What a radical idea. I have two variadic streams of arguments, filenames and options. How to reconcile the two?
    - option1: do you want an absolute prefix?
    - option2: do you want to include CSS files of the same name?
    - option3: do you want to include JS files of the same name?
    - option4: do you want CSS/JS resources to be inlined, or served separately?
        - how to override this on a per-template level?
- How to make persist changes to contenteditable elements to the database, and how to then retrieve it?
    - every contenteditable element has an id which is the key. The innerHTML is the value. A javascript function gathers up items tagged with '.conteneditable' into a JSON payload and does a POST request to /pm-kv. On success it simply reloads the current page.
- What does the API for user-editable fields look like to the template creator?
    <h1 id="plugin_name:title" class="{{ template "pagemanager:contenteditable" . }}">
        {{ $res := pm_kv "plugin_name:title" }}
        {{ if $res.Valid }}{{ $res.Value }}{{ else }}default text{{ end }}
    </h1>
    - pm_kv "plugin_name:title" will pull the relevant value from the database/cache.
    - id="plugin_name:title" together with class="pm-contenteditable" will trigger a pagemanager javascript snippet to transform it into a contenteditable element, and then pulls the value from that element and saves it to the database/cache.
    - quite neat! This isn't even blog stuff, it's inherent in pagemanager. You can use this system for any kind of template that targets pagemanager.
