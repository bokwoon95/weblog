usually pagemanager/blog renders

render.Page(w, r, data, "post-index.html", "post-index.css", "post-index.js")

but before that, it will check the blg_kv table

blg_kv:
    post-index.html -> post-index.html?fs=templates&dir=plainsimple
    post.html -> post.html?fs=templates&dir=plainsimple

note: pagemanager/blog was the one who registered the templates/ directory under as the 'templates' alt FS. so if it sets ?fs=templates, it's guaranteed that the templatesFS exists because it was the one that registered it

anyway pagemanager/blog will look into the plainsimple/ directory (inside the templates/ directory) and find the config.toml. it feeds "post-index.html" as the key and gets back css = ["style.css"], js = ["post-index.js"], data = { summary = "true", some_other_setting = "lorem ipsum" }.

So instead it calls

render.Page(w, r, data, "post-index.html?fs=templates", "style.css?fs=templates", "post-index.js?fs=templates")

and renderly should search for those files accordingly in templatesFS. Also pagemanager/blog got the data = { summary = "true", some_other_setting = "lorem ipsum" }, it uses that to influence the decisions it makes when it comes to injecting the data into the template, like whether it should provide just the post {{ .Summary }} or the entire post {{ .Body }}.

blg_kv:
    post-index -> post-index.html?fs=builtin -> pass 'post-index.html' to
    post-index -> post-index.html?fs=templates&dir=plainsimple

pagemanager/pagemanager
pagemanager/sqladmin
pagemanager/blog
pagemanager/rss
pagemanager/present

templates can be standalone or they can target specific pagemanager plugins.
    the only difference between the two is whether it makes reference to a (yet to be injected) data pipeline
Other than pm_kv strings, templates can also pm_kv array of objects (not sure how that will work yet)
    pm_kv-ing an array of objects allows the user to define repeatable cards rather than just fixed ones
a single filename is enough for pagemanager to find all the necessary html/css/js files to parse together with the main template
    templatesFS implements a translation method that reads from config.toml:
        ["post-index.html"]
        html = ["header.html", "footer.html", "sidebar.html"]
        css = ["style.css"]
        js = ["post-index.js"]
    layout templates are achieved with an optional 'main_html' key. If no main_html is provided, the provided filename will be used as the main template (as usual).
        ["about-me.html"]
        main_html = "layout.html"
        html = ["layout.html", "header.html", "footer.html", "sidebar.html"]
        css = ["style.css"]
        js = ["post-index.js"]
            ["about-me.html".args]
            showbody = true
            datefmt = "01/02/03" # or they could just call the datefmt method on the time.Time value
holy shit toml allows me to bundle markdown files as well, you can just define all your layout stuff in html and your content in markdown
    ["my-blogge-post.md"]
    url = "{{.YYYY}}/{{.MM}}/{{.PostTitle}}" # nah this is wayy too tedious, blog posts should belong under pm/blog. this is more for manually curated pages, like mdn docs
    html = ["header.html", "footer.html", "sidebar.html"]
    css = ["style.css"]
    js = []
    md = ["some-other-stuff.md"]
    main_html = "layout.html"

    # reference the content like this
    <div class="post-body">
        {{ index . "__content__" }}
    </div>
    # you can reference other included md snippets like this
    <div class="footer">{{ index . "some-other-stuff.md" }}</div>

    content-specific key values is defined in the content.md front matter
    this means anytime pagemanager finds a content (.md) file, it will parse the front matter and inject that as part of the page data.
    which means that it definitely has to start categorizing .md files as well
